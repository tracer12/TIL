### 인스턴스 변수란?
- 객체 내에서 고유한 값을 가지는 변수

### 클래스 변수란?
- static을 이용하여 객체간 공통적으로 사용하는 변수

### 클래스란 무엇인가?
- **변수(데이터) 와 메서드(기능)을 가지고 있는 하나의 집합이며 객체를 생성하기 위한 틀!**
단순 의미설명 -> 관련된 속성과 메서드를 묶어 객체를 생성하기 위한 템플릿
ex) 자동차 설계 도면을 생각하자
    - 그러나 같은 자동차여도 부품(승객 출입문(출입문은 부품이다, 출입문을 열고 닫는게 기능이고), 추가바퀴)과 기능(하차벨, 속도제한장치)을 추가하여 버스를 만들 수 있다 -> 이를 클래스 확장이라고 함
- **사용이유 -> 코드를 직관적으로 쉽게 볼 수 있고, 재사용성과 유지보수성을 높이기 위해서.** 
자동차 3대를 만들고 싶을 때 자동차 3대를 일일히 선언하기 보다는 자동차 클래스 하나를 만들고 자동차 객체 3개를 선언해주자.

### 생성자란 무엇인가?

- **객체(인스턴스)를 생성할 때 초기화 해주는 메소드**
-> 객체를 생성하기 위한 유일한 메서드이다. 
ex) 자동차 객체를 만들 때 자동차 이름을 넘겨주고 객체를 생성함
넘겨줄 값이 없는 경우도 있으며 이 경우에는 기본 생성자라고 부른다.
- **생성자는 여러개 선언할 수 있다**
넘겨주는 매개변수의 종류에 따라서 다른 생성자들이 호출됨, 그러나 이름은 전부 클래스의 이름과 같다.
- **여러개 선언할 수 있는 이유**
여러개의 생성자를 통해 다양한 상황에 맞는 초기화를 진행한 객체를 생성할 수 있다. 
사람을 예시로 들면 이름과 나이만 알고있는 경우, 이름과 주소만 알고있는 경우, 이름과 나이, 주소를 전부 모르는 경우 등 다양한 상황에 맞게 초기화를 진행하여 상황에 맞는 객체를 생성할 수 있다.

### this란 무엇인가?

**``this`` -> 클래스의 인스턴스(객체) 변수에 값을 할당하기 위해 해당 객체의 변수를 가르키는 문법.**

1. 객체가 생성됨
2. 생성자 매개변수로 이름이 들어옴
3. 생성된 객체의 변수를 this로 가르키고 있으니 이 this로 가르킨 변수를 들어온 매개변수로 초기화함
-> 그러나 name = name과 같이 해놓으면 매개변수 = 매개변수 이므로 무의미한 코드
-> name = dogName과 같이 매개변수의 이름을 인스턴스 변수와 다르게 해놓으면 this를 사용하지 않아도 됨

**여기서 인스턴스란?**

- 객체는 모든 인스턴스를 포괄하는 넓은 의미를 가지고 인스턴스는 해당 객체가 어떤 클래스로부터 생성된 것인지를 강조한다, 보통 객체 == 인스턴스로 혼용해서 사용하기도 한다.

### 메서드 오버로딩(과부화)란?

- **메서드의 이름은 같고 매개변수의 유형과 개수가 다르도록 하는 것을 의미한다(매개변수의 유형과 개수가 다른것이 중요하다.)**
    - 매개변수 차이없이 리턴값만을 다르게 갖는 오버로딩은 작성할 수 없다. 
    (메서드 앞에 붙는 반환타입의 종류는 영향을 주지 않는다. → 매개변수가 같다면 ``void print (return a)``든 ``int print(return b)``든 같은 메서드로써 오류가 남)
    - ex) 객체를 하나 만들었을 때 이름은 같지만 매개변수가 달라 기능은 다른 여러 메서드를 만들 수 있다. 
    ex) ``System.out.println`` 함수에는 문자, 숫자를 넣을 수 있지만 문제없이 잘 작동한다.

### 메서드 오버라이딩(덮어쓰기)란?

- **상위(부모) 클래스가 가지고 있는 메서드를 하위 클래스가 재정의 해서 사용하는 것을 의미한다
(메서드의 이름과 매개변수의 개수나 타입도 동일해야한다.)**
    - ex) 클래스를 상속받고 하위 클래스로 객체를 하나 생성했을 때 상위 클래스에 있는 test 메서드를 하위 클래스에서 다시 이름과 매개변수는 같게, 기능은 다르게 재 정의하여 사용할 수 있다
    - ``static``과 ``final``이 붙은 메서드는 오버라이딩 불가 private는 상속 자체가 안된다.

### ``static``이란?

- **객체를 생성하지 않아도 사용할 수 있게 해주는 자바의 예약어, static이 붙으면 하나의 객체로 생각해 전역적으로 사용할 수 있게 해준다.**
    - 모든 인스턴스가 값을 공유하므로 어디서 어떻게 사용할지, 값이 변할지 잘 활용해야 한다고 생각.

**static의 사용법**

1. 클래스를 설계할 때 멤버 변수 중 모든 인스턴스에 공통으로 사용하는 것에 static을 선언한다.
2. 클래스 변수(static 변수)는 인스턴스를 생성하지 않아도 호출할 수 있다
3. 클래스 메소드(static 메소드)는 인스턴스 변수를 사용할 수 없다.
static으로 사용하는 변수, 메서드는 static 에서만 공유하고 사용할 수 있다.   
즉 일반 변수와 메서드는 static에 대한 "참조"가 가능하지만 역으로 static 메서드는 일반 클래스 변수를 참조할 수 없다.
-> 인스턴스 메서드에선 static 변수에 바로 접근가능
-> 스태틱 메서드에선 인스턴스 변수에 접근 불가능
4. 메소드 내에서 인스턴스 변수를 사용하지 않는다면, static을 붙이는 것을 고려하자.

### 상속이란?

- **상위(부모)클래스를 받아 확장시키는것, 부모의 모든것(인스턴스 변수, 메서드) 등을 물려받는다.**
    - 상속의 횟수에 제한을 두지는 않았으나 동시에 여러개의 상위 클래스를 상속받는것은 불가능하다.

### 다중상속이란?

- **자식 클래스가 부모 클래스를 여러개 상속받지 못하는것을 말한다**
    
    왜 막아둔걸까?
    
    - 만약 a클래스를 상속받은 b,c 클래스를 d클래스가 동시에 상속받게 된다면 b,c클래스에서 서로 다르게 오버라이딩 한 메서드를 d 클래스는 어떻게 상속받을지 모르게 된다. 
    즉 이를 방지하기 위해 클래스의 다중 상속을 막아두었다(다이아몬드 문제)

### super( ) 키워드란?

- **확장된 자식 클래스에서 부모 클래스를 초기화(자식 클래스의 생성자에서 부모 클래스의 생성자를 호출하여 부모 클래스를 초기화 함, 매개변수를 맞춰야됨) 하기 위한 키워드**
- 확장된 자식 클래스 생성 시 자식 클래스의 생성자에서 부모 클래스의 생성자를 호출하기 위해서 사용되며 가장 첫 줄에 사용되어야 한다.
- **그러나 자식 클래스의 생성자에 부모 클래스의 생성자가 지정되어 있지 않다면 컴파일러가 자동으로 부모 클래스의 기본 생성자를 호출한다.[ super( ) ] 삽입.**
**이때 부모 클래스에 기본 생성자가 없다면 오류가 발생하므로 super()를 이용해 생성자를 지정해줘야한다.**

**POJO란?**

- 특별한 규약이나 프레임워크에 의존적이지 않는 순수한 자바 객체
클래스, 인터페이스, 필드, 메서드 등만 사용해서 작성됨

**private static은 어떤 의미를 가지나?**

- 클래스 내부에서만 접근 가능한 공유데이터, 또는 공유메서드를 구현할 때 사용한다.
클래스 외부에서 접근 불가.
